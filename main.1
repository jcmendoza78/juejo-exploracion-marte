// main.js - Juego de plataformas educativo en Marte (Phaser 3)
// Reemplaza todo el contenido de tu main.js con este archivo.

// Configuración del juego
const GAME_WIDTH = 1280;
const GAME_HEIGHT = 720;
const WORLD_WIDTH = 4000;
const WORLD_HEIGHT = 1200;

const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  backgroundColor: '#0b1020',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 1400 },
      debug: false
    }
  },
  scene: [MainScene]
};

const game = new Phaser.Game(config);

// ---------- Escena principal ----------
function MainScene() {
  Phaser.Scene.call(this, { key: 'MainScene' });
}
MainScene.prototype = Object.create(Phaser.Scene.prototype);
MainScene.prototype.constructor = MainScene;

MainScene.prototype.preload = function() {
  // No assets externos obligatorios: creamos texturas procedurales
  this.createProceduralTextures();
};

MainScene.prototype.create = function() {
  // Variables de estado
  this.score = 0;
  this.totalStations = 0;
  this.completedStations = 0;
  this.stationList = []; // lista de objetos estación
  this.highRouteStations = []; // para insignia de ruta alta

  // Mundo y cámara
  this.physics.world.setBounds(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
  this.cameras.main.setBounds(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

  // Suelo y plataformas
  this.platforms = this.physics.add.staticGroup();
  this.createLevelGeometry();

  // Jugador
  this.createPlayer();

  // Controles
  this.cursors = this.input.keyboard.createCursorKeys();
  this.keyB = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.B);
  this.keyM = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.M);

  // Coyote time y jump buffer
  this.coyoteTimeMax = 120; // ms
  this.jumpBufferMax = 150; // ms
  this.coyoteTimer = 0;
  this.jumpBufferTimer = 0;

  // Estaciones educativas
  this.createStations();

  // Puerta/meta
  this.createDoorAndFlag();

  // Colisiones y overlaps
  this.physics.add.collider(this.player, this.platforms);
  this.physics.add.collider(this.door, this.platforms);
  this.physics.add.collider(this.flag, this.platforms);
  this.physics.add.overlap(this.player, this.stationsGroup, this.onStationOverlap, null, this);

  // Cámara sigue al jugador
  this.cameras.main.startFollow(this.player, true, 0.08, 0.08);

  // UI
  this.createUI();

  // Bitácora (overlay oculto)
  this.bitacoraVisible = false;
  this.createBitacora();

  // Insignajes
  this.badges = {
    allComplete: false,
    highRouteComplete: false
  };
};

MainScene.prototype.update = function(time, delta) {
  // Movimiento horizontal
  const speed = 300;
  if (this.cursors.left.isDown) {
    this.player.setVelocityX(-speed);
    this.player.flipX = true;
  } else if (this.cursors.right.isDown) {
    this.player.setVelocityX(speed);
    this.player.flipX = false;
  } else {
    this.player.setVelocityX(0);
  }

  // Coyote time: si está tocando suelo, resetear
  if (this.player.body.onFloor()) {
    this.coyoteTimer = this.coyoteTimeMax;
  } else {
    this.coyoteTimer -= delta;
  }

  // Jump buffer: si el jugador presiona salto, guardar
  if (Phaser.Input.Keyboard.JustDown(this.cursors.up)) {
    this.jumpBufferTimer = this.jumpBufferMax;
  } else {
    this.jumpBufferTimer -= delta;
  }

  // Ejecutar salto si buffer y coyote disponibles
  if (this.jumpBufferTimer > 0 && this.coyoteTimer > 0) {
    this.player.setVelocityY(-560);
    this.jumpBufferTimer = 0;
    this.coyoteTimer = 0;
  }

  // Bitácora toggle
  if (Phaser.Input.Keyboard.JustDown(this.keyB) || Phaser.Input.Keyboard.JustDown(this.keyM)) {
    this.toggleBitacora();
  }

  // Actualizar UI
  this.updateUI();

  // Check insignias
  this.checkBadges();
};

// ---------- Procedural textures ----------
MainScene.prototype.createProceduralTextures = function() {
  // Player texture
  const g = this.make.graphics({ x: 0, y: 0, add: false });
  g.fillStyle(0xff6f61, 1);
  g.fillRoundedRect(0, 0, 48, 64, 8);
  g.generateTexture('player', 48, 64);
  g.clear();

  // Station texture (inactive)
  g.fillStyle(0xffd166, 1);
  g.fillCircle(16, 16, 16);
  g.generateTexture('station_inactive', 32, 32);
  g.clear();

  // Station texture (active/completed)
  g.fillStyle(0x6ee7b7, 1);
  g.fillCircle(16, 16, 16);
  g.generateTexture('station_active', 32, 32);
  g.clear();

  // Door texture
  g.fillStyle(0x8b5cf6, 1);
  g.fillRect(0, 0, 64, 128);
  g.generateTexture('door', 64, 128);
  g.clear();

  // Flag texture
  g.fillStyle(0xffffff, 1);
  g.fillRect(0, 0, 16, 48);
  g.fillStyle(0xff0000, 1);
  g.fillTriangle(16, 8, 32, 16, 16, 24);
  g.generateTexture('flag', 32, 48);
  g.clear();

  // Platform texture
  g.fillStyle(0x3b3b3b, 1);
  g.fillRect(0, 0, 200, 32);
  g.generateTexture('platform', 200, 32);
  g.clear();
};

// ---------- Nivel y geometría ----------
MainScene.prototype.createLevelGeometry = function() {
  // Suelo extenso
  for (let x = 0; x < WORLD_WIDTH; x += 200) {
    const p = this.platforms.create(x + 100, WORLD_HEIGHT - 40, 'platform');
    p.setScale(1).refreshBody();
  }

  // Plataformas bajas (ruta fácil)
  this.platforms.create(600, WORLD_HEIGHT - 160, 'platform').refreshBody();
  this.platforms.create(900, WORLD_HEIGHT - 220, 'platform').refreshBody();
  this.platforms.create(1400, WORLD_HEIGHT - 180, 'platform').refreshBody();
  this.platforms.create(2000, WORLD_HEIGHT - 200, 'platform').refreshBody();

  // Plataformas altas (ruta retadora)
  this.platforms.create(1200, WORLD_HEIGHT - 420, 'platform').refreshBody();
  this.platforms.create(1600, WORLD_HEIGHT - 520, 'platform').refreshBody();
  this.platforms.create(2200, WORLD_HEIGHT - 480, 'platform').refreshBody();
  this.platforms.create(2800, WORLD_HEIGHT - 520, 'platform').refreshBody();

  // Conectores (escaleras) - simples plataformas verticales
  this.platforms.create(1000, WORLD_HEIGHT - 300, 'platform').setScale(0.2, 4).refreshBody();
  this.platforms.create(2100, WORLD_HEIGHT - 340, 'platform').setScale(0.2, 4).refreshBody();
};

// ---------- Jugador ----------
MainScene.prototype.createPlayer = function() {
  this.player = this.physics.add.sprite(200, WORLD_HEIGHT - 200, 'player');
  this.player.setCollideWorldBounds(true);
  this.player.body.setSize(36, 60).setOffset(6, 4);
  this.player.setBounce(0.05);
};

// ---------- Estaciones educativas ----------
MainScene.prototype.createStations = function() {
  // Definición de estaciones temáticas (añade más si quieres)
  const stationDefs = [
    { x: 600, y: WORLD_HEIGHT - 200, theme: 'Atmósfera', route: 'low',
      title: 'Atmósfera', facts: ['La atmósfera marciana es muy delgada', 'Principalmente CO₂'] },
    { x: 1200, y: WORLD_HEIGHT - 460, theme: 'Agua/Hielo', route: 'high',
      title: 'Agua en Marte', facts: ['Hay hielo en los polos', 'A veces hay flujos salinos'] },
    { x: 1400, y: WORLD_HEIGHT - 220, theme: 'Geología', route: 'low',
      title: 'Rocas marcianas', facts: ['Marte tiene volcanes gigantes', 'El suelo es rico en óxidos'] },
    { x: 1600, y: WORLD_HEIGHT - 560, theme: 'Misiones', route: 'high',
      title: 'Misiones', facts: ['Rovers han explorado la superficie', 'Hay orbitadores en misión'] },
    { x: 2000, y: WORLD_HEIGHT - 240, theme: 'Radiación', route: 'low',
      title: 'Radiación', facts: ['Radiación es mayor que en la Tierra', 'Protección es clave para humanos'] },
    { x: 2200, y: WORLD_HEIGHT - 500, theme: 'Comunicación', route: 'high',
      title: 'Comunicación', facts: ['Retraso de señal puede ser minutos', 'Se usan orbitadores como repetidores'] }
  ];

  this.stationsGroup = this.physics.add.staticGroup();

  stationDefs.forEach((def, idx) => {
    const s = this.stationsGroup.create(def.x, def.y, 'station_inactive');
    s.setData('id', idx);
    s.setData('title', def.title);
    s.setData('theme', def.theme);
    s.setData('facts', def.facts);
    s.setData('completed', false);
    s.setData('route', def.route);
    this.stationList.push(s);
    if (def.route === 'high') this.highRouteStations.push(s);
  });

  this.totalStations = this.stationList.length;
};

// ---------- Overlap con estación ----------
MainScene.prototype.onStationOverlap = function(player, station) {
  if (station.getData('completed')) return;
  // Iniciar mini-retos (2 pasos)
  this.startStationSequence(station);
};

// ---------- Secuencia de mini-retos por estación ----------
MainScene.prototype.startStationSequence = function(station) {
  // Pausar física del jugador para la interacción
  this.player.setVelocity(0, 0);
  this.player.body.moves = false;

  const facts = station.getData('facts');
  const title = station.getData('title');

  // Estructura: paso 1 = pregunta tipo secuencia/orden (simulada), paso 2 = quiz VF o MC
  const step1 = {
    type: 'sequence',
    prompt: `Paso 1 — Ordena: ¿Cuál es un dato clave sobre ${title}?`,
    options: facts.slice().sort(() => 0.5 - Math.random()) // mezclar
  };

  const step2 = {
    type: 'tf',
    prompt: `Paso 2 — Verdadero o Falso: "${facts[0]}" es correcto?`,
    answer: true
  };

  // Mostrar UI de estación
  this.showStationUI(station, [step1, step2], 0);
};

MainScene.prototype.showStationUI = function(station, steps, index) {
  // Crear overlay simple
  if (this.stationUI) this.stationUI.destroy(true);
  const w = 520, h = 220;
  const x = this.cameras.main.worldView.x + (GAME_WIDTH / 2) - w/2;
  const y = this.cameras.main.worldView.y + (GAME_HEIGHT / 2) - h/2;

  const container = this.add.container(x, y);
  const bg = this.add.rectangle(0, 0, w, h, 0x071126, 0.95).setOrigin(0);
  const border = this.add.rectangle(0, 0, w, h).setStrokeStyle(2, 0xffffff).setOrigin(0);
  container.add([bg, border]);

  const titleText = this.add.text(20, 12, `Estación: ${station.getData('title')}`, { font: '20px Arial', fill: '#fff' });
  container.add(titleText);

  const step = steps[index];

  const promptText = this.add.text(20, 50, step.prompt, { font: '18px Arial', fill: '#fff', wordWrap: { width: w - 40 } });
  container.add(promptText);

  // Interacción según tipo
  if (step.type === 'sequence') {
    // Mostrar opciones y permitir seleccionar la que creas más relevante (simulación)
    const opts = step.options;
    const optTexts = [];
    opts.forEach((o, i) => {
      const t = this.add.text(40, 90 + i*28, `${i+1}. ${o}`, { font: '16px Arial', fill: '#fff' });
      t.setInteractive({ useHandCursor: true });
      t.on('pointerdown', () => {
        // Aceptamos cualquier selección como "completado" para mantener flujo educativo
        this.showStationUI(station, steps, index + 1);
      });
      container.add(t);
      optTexts.push(t);
    });
    const hint = this.add.text(20, h - 36, 'Haz clic en la opción que consideres correcta.', { font: '14px Arial', fill: '#ddd' });
    container.add(hint);
  } else if (step.type === 'tf') {
    const trueBtn = this.add.rectangle(140, 140, 120, 40, 0x2ecc71).setInteractive({ useHandCursor: true });
    const falseBtn = this.add.rectangle(340, 140, 120, 40, 0xe74c3c).setInteractive({ useHandCursor: true });
    const tText = this.add.text(140, 140, 'Verdadero', { font: '16px Arial', fill: '#000' }).setOrigin(0.5);
    const fText = this.add.text(340, 140, 'Falso', { font: '16px Arial', fill: '#000' }).setOrigin(0.5);
    container.add([trueBtn, falseBtn, tText, fText]);

    trueBtn.on('pointerdown', () => {
      this.finishStation(station, true);
      container.destroy(true);
      this.stationUI = null;
    });
    falseBtn.on('pointerdown', () => {
      this.finishStation(station, false);
      container.destroy(true);
      this.stationUI = null;
    });
  }

  // Guardar referencia para destruir luego
  this.stationUI = container;
};

MainScene.prototype.finishStation = function(station, userAnswer) {
  // Para este prototipo, consideramos correcto si userAnswer coincide con truthy del primer fact (simulado)
  // Marcar completada
  station.setData('completed', true);
  station.setTexture('station_active');
  this.completedStations += 1;
  this.score += 100;

  // Añadir entrada a bitácora (tomamos el primer dato como "clave")
  const facts = station.getData('facts');
  station.setData('learned', { title: station.getData('title'), keyFact: facts[0] });

  // Reactivar movimiento del jugador
  this.player.body.moves = true;

  // Si completó todas, abrir puerta
  if (this.completedStations >= this.totalStations) {
    this.openDoor();
  }
};

// ---------- Puerta y bandera ----------
MainScene.prototype.createDoorAndFlag = function() {
  // Puerta bloqueando el camino hacia la bandera
  this.door = this.physics.add.staticSprite(WORLD_WIDTH - 400, WORLD_HEIGHT - 160, 'door');
  this.door.setDepth(1);
  this.flag = this.physics.add.staticSprite(WORLD_WIDTH - 200, WORLD_HEIGHT - 160, 'flag');
  this.flag.setData('reached', false);

  // Colisión puerta-jugador: bloquea
  this.physics.add.collider(this.player, this.door, () => {
    // opcional: mensaje o sonido
  }, null, this);

  // Overlap con bandera para terminar nivel (solo si puerta abierta)
  this.physics.add.overlap(this.player, this.flag, () => {
    if (this.completedStations >= this.totalStations && !this.flag.getData('reached')) {
      this.flag.setData('reached', true);
      this.onLevelComplete();
    }
  }, null, this);
};

MainScene.prototype.openDoor = function() {
  // Animación simple: fade out y destroy
  this.tweens.add({
    targets: this.door,
    alpha: 0,
    duration: 800,
    onComplete: () => {
      this.door.destroy();
      // premio visual
      this.add.text(this.door.x - 80, this.door.y - 160, 'Puerta abierta', { font: '18px Arial', fill: '#fff' }).setDepth(10);
    }
  });
};

// ---------- Nivel completado ----------
MainScene.prototype.onLevelComplete = function() {
  // Mostrar mensaje y otorgar insignia si aplica
  this.add.rectangle(this.cameras.main.worldView.x + GAME_WIDTH/2 - 220, this.cameras.main.worldView.y + GAME_HEIGHT/2 - 80, 440, 160, 0x071126, 0.95).setOrigin(0);
  this.add.text(this.cameras.main.worldView.x + GAME_WIDTH/2, this.cameras.main.worldView.y + GAME_HEIGHT/2 - 20, '¡Nivel completado!', { font: '28px Arial', fill: '#fff' }).setOrigin(0.5);
  this.score += 500;

  // Marcar insignia de "allComplete"
  this.badges.allComplete = true;
};

// ---------- UI ----------
MainScene.prototype.createUI = function() {
  // Texto fijo en cámara (usamos scrollFactor 0 para que siga cámara)
  this.uiText = this.add.text(16, 16, '', { font: '18px Arial', fill: '#fff' }).setScrollFactor(0);
  this.updateUI();
};

MainScene.prototype.updateUI = function() {
  this.uiText.setText([
    `Estaciones: ${this.completedStations} / ${this.totalStations}`,
    `Puntos: ${this.score}`,
    `Bitácora: presiona B o M`
  ]);
};

// ---------- Bitácora ----------
MainScene.prototype.createBitacora = function() {
  // Contenedor oculto
  this.bitacoraContainer = this.add.container(40, 80).setScrollFactor(0).setDepth(50);
  const bg = this.add.rectangle(0, 0, 420, 520, 0x02121f, 0.95).setOrigin(0);
  const border = this.add.rectangle(0, 0, 420, 520).setStrokeStyle(2, 0xffffff).setOrigin(0);
  const title = this.add.text(20, 12, 'Bitácora marciana', { font: '20px Arial', fill: '#fff' });
  this.bitacoraContainer.add([bg, border, title]);
  this.bitacoraEntries = this.add.container(20, 50);
  this.bitacoraContainer.add(this.bitacoraEntries);
  this.bitacoraContainer.setVisible(false);
};

MainScene.prototype.toggleBitacora = function() {
  this.bitacoraVisible = !this.bitacoraVisible;
  this.bitacoraContainer.setVisible(this.bitacoraVisible);
  if (this.bitacoraVisible) this.refreshBitacora();
};

MainScene.prototype.refreshBitacora = function() {
  this.bitacoraEntries.removeAll(true);
  let y = 0;
  this.stationList.forEach((s, idx) => {
    const completed = s.getData('completed');
    const title = s.getData('title');
    const learned = s.getData('learned');
    const statusText = completed ? 'Completada' : 'Pendiente';
    const color = completed ? '#6ee7b7' : '#ffd166';
    const t = this.add.text(0, y, `${idx+1}. ${title} — ${statusText}`, { font: '16px Arial', fill: color });
    this.bitacoraEntries.add(t);
    y += 22;
    if (learned) {
      const fact = this.add.text(12, y, `• ${learned.keyFact}`, { font: '14px Arial', fill: '#ddd' });
      this.bitacoraEntries.add(fact);
      y += 20;
    }
  });

  // Progreso e insignias
  const progress = this.add.text(0, y + 8, `Progreso: ${this.completedStations}/${this.totalStations}`, { font: '16px Arial', fill: '#fff' });
  this.bitacoraEntries.add(progress);
  y += 36;

  // Insignias visibles
  const badgesText = [];
  if (this.badges.allComplete) badgesText.push('Insignia: Explorador Marciano');
  if (this.badges.highRouteComplete) badgesText.push('Insignia: Valiente de la Ruta Alta');
  const btxt = this.add.text(0, y, badgesText.join(' • ') || 'Insignias: ninguna', { font: '14px Arial', fill: '#ffd166' });
  this.bitacoraEntries.add(btxt);
};

// ---------- Insignias: comprobación ----------
MainScene.prototype.checkBadges = function() {
  // Si todas las estaciones en ruta alta están completadas, dar insignia
  if (!this.badges.highRouteComplete) {
    const allHighDone = this.highRouteStations.length > 0 && this.highRouteStations.every(s => s.getData('completed'));
    if (allHighDone) {
      this.badges.highRouteComplete = true;
      // Mensaje breve
      this.add.text(this.player.x - 120, this.player.y - 120, 'Insignia: Ruta Alta', { font: '16px Arial', fill: '#ffd166' }).setDepth(20).setScrollFactor(0).setAlpha(0.95);
    }
  }
};

// ---------- Utilidades / debug helpers ----------
MainScene.prototype.debugLog = function(msg) {
  console.log('[Game]', msg);
};
